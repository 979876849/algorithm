 
# 冒泡排序 (Bubble Sort)

原理：重复走访需要排序的元素列，依次比较两个相邻的元素，若顺序错误，则将其二者交换，直至没有相邻元素需要交换。
名字由来: 越小的元素会经过交换慢慢“浮”上来，形似冒出气泡，故名“冒泡排序”。

冒泡排序gif演示图：

![avatar](./冒泡排序演示.gif)



示例：
给定arr1 = [6,3,76,83,5], 使用冒泡排序将其从小到大排列


### 解题思路：通过中间量temp置换比较数的位置

#### 具体实现
通过两两比较数，若arr[i]<arr[i+1],则继续比较后面两个数，若arr[i]>arr[i+1],则将arr[i] 与 arr[i+1] 位置置换，继续比较后两个数，直至数组排序为从小到大的升序。


#### 参考代码（Java）
```

``` 


#### 复杂度
时间复杂度为：O(n²)
时间复杂度用以定性的描述算法运行的时间。
在冒泡排序中，最佳情况为：只需排序一次，即n个数只需排序一次即可，则时间复杂度为O(n)，
             最坏情况为：数逆序排列，问题规模为n，且需要排序n-1次，则时间复杂度为O(n²)，
             平均时间复杂度：O(n²)。

空间复杂度为：O(1)
是对一个算法在运行过程中临时占用存储空间大小的量度。
在冒泡排序中，空间复杂度就是在交换元素时那个临时变量所占的内存空间，
             最佳情况为：最开始数即按照既定顺序排好（如：升序），无需交换，空间复杂度为0,
             最坏情况为：数逆序排列，则需要交换n-1次，空间复杂度为O(n),
             平均空间复杂度为O(1)



#### 参考代码（Java）
```
	private static int [] BubbleSort(int[] arr) {
		for (int i = 0; i < arr.length; i++) {
			for (int j = i+1; j < arr.length; j++) {
				if (arr[i]>arr[j]) {
					int temp = arr[i];
					arr[i] = arr[j];
					arr[j] = temp;
				}
			}
		}
		return arr;
	}
        
```

### 补充、拓展与延伸
后续更新，敬请关注...........